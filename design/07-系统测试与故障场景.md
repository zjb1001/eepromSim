# 07-系统测试与故障场景

> **目标**：完整的测试金字塔(UT/IT/ST/MT/Perf)与30+故障库,驱动P0/P1/P2故障的100%/≥90%/覆盖,建立性能基准与可靠性指标。  
> **适用读者**：QA/测试工程师,质量管理。  
> **本章对标**：终稿§13「质量保障体系」与§5「关键难点攻关」。  
> **输出物**：
> - 测试金字塔策略与用例矩阵
> - 故障库完整清单(30+场景,P0/P1/P2分级)
> - 性能基准与回归检查规则
> - 突变测试计划与杀死率目标
> - 覆盖率检查清单与门禁
> - 度量报告模板与仪表板
> - RTM钩子(REQ-可靠性/性能/合规)

## 1. 完整测试金字塔

### 1.1 单元测试（UT）≥50个用例

**目标覆盖率**：语句覆盖 >95% / 分支覆盖 >90% / 路径覆盖 >85%

**测试范围**：
| 模块 | 函数数量 | 用例数 | 覆盖目标 | 复杂度限制 |
|-----|--------|--------|---------|----------|
| NvM状态机 | 8 | 15 | 100% | <10 |
| 任务队列 | 6 | 12 | 100% | <8 |
| CRC计算 | 4 | 8 | 100% | <5 |
| RAM镜像 | 5 | 10 | 100% | <8 |
| 故障恢复 | 5 | 8 | 100% | <9 |

**示例单元测试**：
```c
// tests/unit/test_nvm_state_machine.c
void test_init_to_idle_transition(void) {
    NvM_Init();
    assert_equals(NvM_State, NVM_STATE_IDLE);
    // 覆盖：状态转移+初始化路径
}

void test_readblock_async_pending(void) {
    NvM_ReadBlock(BLOCK_VIN);
    assert_equals(NvM_GetErrorStatus(BLOCK_VIN), NVM_REQ_PENDING);
    // 覆盖：异步操作+状态查询
}

void test_write_verify_fail_recovery(void) {
    // 注入故障：写后校验失败
    FaultInj_Enable(FAULT_WRITE_VERIFY_FAIL);
    NvM_WriteBlock(BLOCK_ODOMETER);
    NvM_MainFunction(); // 触发重试
    assert_equals(retry_count, 1);
    // 覆盖：故障恢复路径
}
```

### 1.2 集成测试（IT）≥20个用例

**目标覆盖率**：语句覆盖 >90% / 分支覆盖 >85%

**测试场景**：
| 场景 | 涉及模块 | 用例数 | 验证点 |
|-----|--------|--------|--------|
| ReadAll启动流程 | NvM+MemIf+Eep | 3 | Block队列、状态转移、完成通知 |
| WriteAll关机流程 | NvM+Job队列+RAM镜像 | 3 | 脏数据检测、两阶段提交、恢复 |
| 多Block并发 | NvM+优先级+调度器 | 3 | 抢占、队列排序、优先级保证 |
| CRC和冗余 | NvM+完整性+故障注入 | 4 | CRC失败恢复、冗余切换、降级 |
| 虚拟OS集成 | NvM_MainFunction+调度器 | 4 | 任务周期、延迟注入、时间刻度 |
| 配置生成 | ARXML解析+代码生成 | 3 | 配置一致性、MISRA合规、性能无回归 |

**示例集成测试**：
```c
// tests/integration/test_readall_flow.c
void test_readall_multi_blocks_with_priority(void) {
    // 配置：3个Block，优先级不同
    NvM_Block_t blocks[] = {
        {id: 0, priority: HIGH, size: 256},
        {id: 1, priority: LOW, size: 512},
        {id: 2, priority: MEDIUM, size: 128},
    };
    
    NvM_ReadAll();
    
    // 验证1：队列按优先级排序
    assert_queue_order(BLOCK_0, BLOCK_2, BLOCK_1);
    
    // 验证2：按顺序完成
    while (!NvM_ReadAll_Complete()) {
        NvM_MainFunction();
    }
    assert_all_blocks_valid();
    
    // 验证3：性能基准（WriteAll<100ms@10X）
    assert_elapsed_time < 100;
}
```

### 1.3 系统/故障测试（ST）≥30个用例

**覆盖原则**：P0故障100% / P1故障≥90% / P2故障代表性覆盖

### 1.4 突变测试（MT）

**目标杀死率**：>80%，识别难杀死变体并改进

**优先级排序**：
1. NvM状态机（优先级最高）
2. 故障恢复逻辑
3. RAM镜像脏数据检测
4. 队列优先级排序

### 1.5 性能测试（Perf）

**基准用例**：WriteBlock / ReadBlock / WriteAll / ReadAll (各不同大小)

**回归阈值**：<5% 相比基准

### 1.6 合规测试（Compliance）

**验证项**：AUTOSAR API签名、状态机、配置项、MISRA-C规则

## 2. 完整故障库（30+场景）

### 2.1 P0级故障（严重，100%覆盖）

| FI_ID | 故障名称 | 触发条件 | 预期行为 | 验证点 | 关键代码 |
|-------|---------|---------|---------|--------|----------|
| P0-01 | PowerLoss_PageProgram | Eep_Write返回后立即掉电 | 数据半写→CRC失败→recovery | Block状态、CRC值、恢复计数 | src/eeprom/fault_plugins/power_loss.c |
| P0-02 | PowerLoss_WriteAll | WriteAll Phase2中断 | 已写Block恢复、未写Block跳过 | 恢复检查点、Block版本号 | src/nvm/write_all.c:phase2 |
| P0-03 | BitFlip_SingleBit | Eep_Read返回后单bit反转 | CRC失败→冗余或ROM恢复 | CRC计数、冗余命中 | fault_plugins/bit_flip.c |
| P0-04 | BitFlip_MultiBits | Eep_Read返回多bit反转 | CRC必失→降级到只读 | CRC失败计数、降级标志 | fault_plugins/multi_bit_flip.c |
| P0-05 | Timeout_50ms | NvM_MainFunction延迟50ms | Job超时→状态机重置 | Job超时计数、队列清空 | job_queue.c:timeout_handler |
| P0-06 | Timeout_Erase | Erase操作3ms超时 | Block标记UNINITIALIZED | 状态转移日志 | eeprom_sim.c:erase |
| P0-07 | CRC_Invert | Crc_Calculate返回反向值 | 总是失败→ROM默认 | CRC返回值、恢复路径 | fault_plugins/crc_invert.c |
| P0-08 | WriteVerify_Always_Fail | MemIf_Read验证总是失败 | 重试3次→降级为PENDING | 重试计数、最终状态 | data_integrity.c:write_verify |
| P0-09 | RAMCorrupt_PreWrite | WriteBlock前RAM被修改 | 脏数据检测→重新采集 | Snapshot校验和、重新提交 | ram_mirror.c:dirty_detect |
| P0-10 | JobQueue_Overflow | Job队列>32全满 | 新请求拒绝或替换策略 | 队列水位、返回码 | job_queue.c:enqueue |

### 2.2 P1级故障（中等，≥90%覆盖）

| FI_ID | 故障名称 | 触发条件 | 预期行为 | 验证点 | 关键代码 |
|-------|---------|---------|---------|--------|----------|
| P1-11 | MultiBlock_Concurrent_Fail | 2个Block同时ReadBlock,一个失败 | 另一个继续、失败Block恢复 | 两个Block最终状态都OK | test_concurrent_*.c |
| P1-12 | StateMachine_Interrupt | 状态转移中被WriteAll中断 | WriteAll优先级更高、等待恢复 | 状态日志、完成顺序 | nvm_state.c |
| P1-13 | WriteCount_Overflow | Block写计数器溢出 | 循环到0、不影响CRC | 写计数器值 | block_lifecycle.c |
| P1-14 | RAM_Persistent_RaceCondition | 同步RAM后立即写EEPROM | 捕获脏数据→重试 | 脏标志、重试计数 | synchronize.c |
| P1-15 | CRC_Type_Mismatch | Block配置CRC类型不一致 | 初始化失败或日志警告 | 配置验证日志 | config_validation.c |
| P1-16 | Redundancy_Both_Fail | 主副本都CRC失败 | 尝试ROM默认 | 恢复路径、最终值 | redundancy.c |
| P1-17 | MemIf_Timeout | MemIf_Write耗时超过配置 | 标记超时、队列调整 | 超时日志、队列状态 | memif_shim.c |
| P1-18 | Block_SizeMismatch | 读出Block大小≠配置大小 | 完整性检查失败、标记INVALID | 块大小校验日志 | block_validate.c |
| P1-19 | Dataset_IndexOutOfRange | NvM_SetDataIndex超出范围 | 返回NVM_REQ_INTEGRITY_FAILED | 错误码 | dataset.c |
| P1-20 | Priority_Inversion | 高优先级Block被低优先级阻塞 | 检测器发出警告、调整策略 | 优先级日志 | priority_queue.c |

### 2.3 P2级故障（低概率，代表性覆盖）

| FI_ID | 故障名称 | 触发条件 | 预期行为 | 验证点 | 关键代码 |
|-------|---------|---------|---------|--------|----------|
| P2-21 | RaceCondition_CAS | Compare-And-Swap竞态 | 原子性保证、日志记录 | 原子操作计数 | atomicity.c |
| P2-22 | QuickPowerRestart | 掉电后<10ms快速重启 | 恢复点检查、重启日志 | 快速重启次数 | recovery.c |
| P2-23 | TemperatureExtreme | 极限温度下EEPROM延迟变化 | 性能受影响<10%、不丢数据 | 性能基准对比 | thermal_sim.c |
| P2-24 | WearOut_Endurance | Block写次数接近Endurance上限 | 发出寿命警告 | 寿命计数器 | wear_track.c |

**故障库映射到源代码**：
```bash
src/eeprom/
├── fault_plugins/
│   ├── power_loss.c       # P0-01, P0-02
│   ├── bit_flip.c         # P0-03, P0-04
│   ├── crc_invert.c       # P0-07
│   ├── timeout.c          # P0-05, P0-06, P1-17
│   └── ...
├── eeprom_sim.c           # EEPROM模拟器核心
└── fault_injection.h      # FaultInj_Enable(FI_ID)
```

**故障激活示例**：
```c
// tests/system/test_fault_recovery.c
void test_p0_power_loss_during_write(void) {
    FaultInj_Enable(P0_POWERLOSS_PAGEPROGRAM);
    NvM_WriteBlock(BLOCK_VIN);
    NvM_MainFunction();  // 触发Eep_Write → 注入掉电
    // ... NvM应该恢复
    assert_block_state(BLOCK_VIN, NVM_BLOCK_RECOVERED);
}

void test_p1_multiblock_concurrent_failure(void) {
    FaultInj_Enable(P1_MULTIBLOCK_CONCURRENT_FAIL);
    FaultInj_SetBlockTarget(BLOCK_ODOMETER);  // 指定失败Block
    NvM_ReadBlock(BLOCK_VIN);
    NvM_ReadBlock(BLOCK_ODOMETER);
    while (!NvM_ReadAll_Done()) NvM_MainFunction();
    assert_block_ok(BLOCK_VIN);
    assert_block_recovered(BLOCK_ODOMETER);
}
```

## 3. 性能基准与回归检查

### 3.1 关键路径基准（@虚拟时间刻度10X）

| 操作 | Block大小 | 期望耗时(ms) | CPU占用(%) | 内存峰值(KB) | 测试用例 |
|-----|----------|-------------|-----------|-------------|----------|
| ReadBlock | 256B | <15 | <5 | 2 | perf_read_256 |
| WriteBlock | 256B | <20 | <5 | 2 | perf_write_256 |
| ReadBlock | 1KB | <30 | <8 | 4 | perf_read_1k |
| WriteBlock | 1KB | <40 | <8 | 4 | perf_write_1k |
| ReadAll (3块) | 1KB总计 | <60 | <10 | 8 | perf_readall_3blocks |
| WriteAll (3块) | 1KB总计 | <80 | <12 | 8 | perf_writeall_3blocks |
| 故障恢复(P0) | - | <50ms | <20 | 10 | perf_recovery_p0 |

### 3.2 回归检查规则

```bash
# CI中运行基准测试并对比
./tools/run_perf_tests.sh --baseline baseline.json --output current.json

# 回归检查：每个指标与上一版本对比
if (current.WriteBlock_256ms - baseline.WriteBlock_256ms) > 20% * baseline.WriteBlock_256ms:
    FAIL  # 性能下降超过5%阈值
else:
    PASS

# 存储历史数据用于趋势分析
echo "$(date),$(perf_data)" >> docs/perf/history.csv
```

### 3.3 实时安全验证场景（对标SG3 WriteAll <100ms）

| 测试ID | 场景 | 输入条件 | 验收标准 | 观测点 | 关联文件 |
|--------|------|---------|---------|--------|---------|
| ST-SG3-01 | WriteAll关机期限 | N=10 Blocks，总1KB，10X倍速 | 完成时间 <100ms；无deadline_miss | NvM_RuntimeDiagnostics.deadline_miss_count=0 | tests/perf/test_writeall_deadline.c |
| ST-SG3-02 | 调度抖动50ms | NvM_MainFunction延迟=50ms | 触发FAULT_REPORT(TIMING_VIOLATION)；系统回滚一致 | Fault log，Job队列状态，Block一致性 | tests/system/test_sg3_jitter.c |
| ST-SG3-03 | 掉电+超时组合 | WriteAll Phase2 + PowerLoss + 抖动10ms | 失败可检测；Block不撕裂；重启后恢复OK | Block CRC，版本号，恢复计数 | tests/system/test_sg3_powerloss_timeout.c |

**验证重点**：
- 计时基准：VirtualTime_GetUs/GetMs 与实时刻度对齐（误差<1%）。
- 监控：NvM_RuntimeDiagnostics.max_execution_time_us、deadline_miss_count 需在日志中输出；FAULT_REPORT 应记载违规时间。
- 回滚：超时或故障触发时，WriteAll 完整回滚或标记未完成，不得留半写 Block。

## 4. 突变测试（MT）计划

### 4.1 高优先级模块（杀死率目标>85%）

**NvM状态机** (src/nvm/state_machine.c):
- 变体：条件反转 (== → !=)、边界值 (< → ≤)、状态跳转
- 示例变体：
  ```c
  // 原始
  if (state == NVM_STATE_IDLE) { ... }
  
  // 变体1：条件反转
  if (state != NVM_STATE_IDLE) { ... }
  
  // 变体2：边界变化
  if (state < NVM_STATE_IDLE) { ... }
  ```

**故障恢复逻辑** (src/nvm/data_integrity.c):
- 变体：跳过恢复步骤、修改恢复策略顺序、条件反转

### 4.2 中等优先级模块（杀死率目标>80%）

**RAM镜像脏数据检测** (src/nvm/ram_mirror.c)
**队列优先级排序** (src/nvm/job_queue.c)

### 4.3 存活体分析与改进计划

```
如果存活体>20%：
1. 分析存活变体特征（如条件超边界但不影响结果）
2. 增加测试用例覆盖边界情况
3. 考虑代码重构简化复杂分支
```

## 5. 覆盖率门禁与检查清单

### 5.1 v1.0发布门禁

| 指标 | 目标 | 检查方法 | 通过标准 |
|-----|------|--------|----------|
| 语句覆盖(UT) | >95% | gcov/lcov | 需要达成 |
| 分支覆盖(UT) | >90% | gcov/lcov | 需要达成 |
| 语句覆盖(UT+IT) | >92% | gcov | 需要达成 |
| 故障覆盖(P0) | 100% | 故障库 | 10/10覆盖 |
| 故障覆盖(P1) | ≥90% | 故障库 | ≥9/10覆盖 |
| 故障覆盖(P2) | 代表性 | 故障库 | ≥3/4覆盖 |
| 圈复杂度 | <10 | cppcheck | max<10 |
| MISRA-C | 100% | cppcheck | 0个违规 |
| 性能回归 | <5% | perf_test | pass |
| 突变杀死率 | >80% | mutant | kill_rate>80% |
| RTM覆盖 | 100% | 自动检查 | 所有REQ有测试 |

### 5.2 每日CI流程

```bash
# 1. 编译与静态检查
make clean all CFLAGS="-fprofile-arcs -ftest-coverage"
cppcheck --std=c99 --enable=all src/

# 2. 单元测试
./bin/test_unit 2>&1 | tee ut.log
gcov src/nvm/*.c -o build/
lcov -c -d build/ -o coverage.info
genhtml coverage.info -o coverage_report/

# 3. 集成测试（可选，仅周检查）
./bin/test_integration

# 4. 性能基准（可选，仅发布前）
./tools/run_perf_tests.sh

# 5. RTM验证
python tools/rtm_gen.py --verify design/ src/ tests/
```

### 5.3 覆盖率报告模板

生成文件 `docs/qa/coverage-v1.0.0.md`：
```markdown
# 覆盖率报告 - v1.0.0

| 层级 | 语句覆盖 | 分支覆盖 | 路径覆盖 | 状态 |
|-----|---------|---------|---------|------|
| UT | 97.2% | 92.5% | 88.1% | ✓ PASS |
| UT+IT | 94.8% | 89.3% | 85.2% | ✓ PASS |

**故障覆盖**：
- P0: 10/10 = 100% ✓
- P1: 9/10 = 90% ✓ (P1-21缓期到v1.1)
- P2: 3/4 = 75% ✓ (P2-23已在热测试中)

**突变测试**：
- NvM状态机: 42/45 杀死 (93%) ✓
- 故障恢复: 38/42 杀死 (90%) ✓
- 存活体分析: 见 docs/qa/mutant-survivors-v1.0.0.md
```

## 6. RTM钩子

```
REQ-可靠性/性能/合规:
├─ REQ-P0故障100覆盖
│  ├─ 设计规范: 02章§3.1 + 04章§3
│  ├─ 故障库: 本章§2.1 (P0-01 ~ P0-10)
│  ├─ 源代码: src/eeprom/fault_plugins/*
│  └─ 测试: tests/system/test_p0_*.c (10个用例，100%覆盖)
├─ REQ-性能基准<5%回归
│  ├─ 设计规范: 本章§3.1
│  ├─ 源代码: src/nvm/nvm_main.c (核心路径)
│  └─ 测试: tests/perf/perf_*.c (8个基准测试)
├─ REQ-SG3实时安全 (WriteAll<100ms + 可检测超时)
│  ├─ 设计规范: 01章§6.5 + 02章§5.5 + 本章§3.3
│  ├─ 监控实现: NvM_RuntimeDiagnostics.deadline_miss_count/max_execution_time_us
│  └─ 测试: tests/perf/test_writeall_deadline.c, tests/system/test_sg3_jitter.c, tests/system/test_sg3_powerloss_timeout.c
└─ REQ-AUTOSAR 4.3兼容
   ├─ 设计规范: 06章§1~2
   ├─ 源代码: src/nvm/nvm_*.c (所有API)
   └─ 测试: tests/compliance/compliance_*.c
```
