# 00-项目开发规范（v1.0 终稿）

> 目标：为 eepromSim 项目提供可执行的工程规范，保证代码、流程、质量门禁与 ASPICE L2 / MISRA-C / CI 要求一致。  
> **版本映射**：本规范支撑v3.0终稿中的第8-13章（工程实施、质量保障、成本规划、风险管理）。  
> **基线约束**：所有变更必须保持与《整体规划_v3.0_终稿》双向追溯；修改规范须经架构师与整稿文档同步。

### Phase与分阶段验收标准（对应v3.0终稿 第7章）

| 阶段 | 时间 | 入口条件 | 出口条件（验收门禁） | 交付物 | RTM |
|-----|------|--------|-------------------|-------|-----|
| **Phase 1** | W1-4 | 需求冻结，架构初稿 | UT>80%, Cyclomatic<12, 0 Critical, API框架<500行定义 | 虚拟硬件框架+虚拟OS原型 | REQ-架构/虚拟硬件 |
| **Phase 2** | W5-8 | Phase1全绿，Job队列模块入库 | UT>95%, IT冒烟>50%, State Machine验证通过 | NvM核心+State机+Job队列 | REQ-NvM核心逻辑 |
| **Phase 3** | W9-12 | Phase2全绿，多Block/ReadAll/WriteAll设计冻结 | UT>95%, IT>90%, P0故障100%, P1故障≥90% | 多Block+配置生成器+故障库 | REQ-复杂机制 |
| **Phase 4** | W13-16 | Phase3全绿，文档初稿完成 | UT>95%, IT>90%, ST全通, 性能基线稳定<5%, ARXML转换工具验证 | v1.0 Release + 7章文档+演示视频 | REQ完整追溯 |

## 1. 范围与目标

### 1.1 遵循标准与版本对标
- **ASPICE L2 实践**：精简版V模型，双向追溯矩阵（RTM），变更管理流程。
- **ISO 26262 流程**：需求→设计→实现→验证→发布全链路；故障注入验证对标ASIL等级。
- **MISRA-C 2012**：必选规则100%，建议规则≥90%；cppcheck严格检查（0 Critical/High）。
- **SemVer与里程碑**：vX.Y.Z命名；发布前冻结3天，发布后48h补充回归报告。
- **与终稿映射**：第00章规范→终稿第8-13章（工程实施、质量、成本、风险）；修改此规范需同步终稿。

### 1.2 适用范围与排除
- **在管范围**：src/*、tools/*、tests/*、docs/design/*、.devcontainer/*、.github/workflows/* 所有变更。
- **管理深度**：包含代码规范、流程规范、度量规范、文档规范；不含第三方库源代码。
- **关键模块规范**：虚拟OS调度器（src/os_shim/）、故障注入（src/eeprom/fault_*）、配置适配（tools/config_gen/）需专章规范。

### 1.3 质量门槛与DoD
**质量指标**：
- 代码覆盖率：UT>95% 语句 >90% 分支 / IT>90% 语句 >85% 分支。
- 代码复杂度：Cyclomatic ≤10，注释密度>80%（行注释+块注释）。
- 编译与分析：CI零告警（gcc -Wall -Wextra -Werror），cppcheck 0 Critical，MISRA必选规则100%。
- 性能与可靠性：关键路径延迟<5%回归；故障恢复MTTR<100ms；P0故障100%覆盖，P1故障≥90%覆盖。

**交付完成定义（DoD）**：
- ✅ 需求完整性：每个需求(REQ-xxxx)已追溯至设计/代码/测试用例。
- ✅ 设计文档：新增功能须更新对应design/0x-*.md，补充关键路径时序与错误处理。
- ✅ 代码质量：通过编译、静态分析、动态分析(asan/ubsan)；代码审查+2人复核。
- ✅ 测试交付：新增功能需提供UT+IT；故障类特性需P0/P1完整场景覆盖。
- ✅ 文档与示例：API文档Doxygen100%覆盖；涉及新特性需提供示例(>100行)或更新existing示例。
- ✅ RTM与追溯：RTM表格同步更新，PR描述含RTM变更摘要。
- ✅ CI与签入：CI全绿无新告警；PR审批人为架构师；签入前必须冻结期无缺陷发现。

## 2. 角色与 RACI
- 架构师：R(设计) / A(审批) — 架构、关键技术决策、里程碑验收，PR 豁免签署人。
- 资深开发：R — 核心模块实现、性能/故障方案落地，复杂度与性能基线评审。
- 开发工程师：R — 功能实现、UT/IT/故障用例编写，静态分析修复。
- QA 工程师：R — 测试策略、覆盖率/性能/故障基线，报告与度量维护。
- 文档工程师：R — 教学文档、API 文档、发布说明、变更单。
- 审批人：架构师；审阅人：资深开发与 QA；执行人：对应模块负责人。

## 3. 分支与版本策略
- 分支模型：main（受保护） / dev（集成） / feature-* / hotfix-*。
- PR 流程：feature-* → PR 到 dev，必须通过全量 CI；架构师每周/里程碑合并 dev → main。
- 版本：SemVer；发布标签示例 v0.1-alpha、v1.0.0；RC 标签用于发布候选（rcN）。
- 代码冻结：里程碑前 3 天冻结新功能，仅接受阻断缺陷；冻结期间需附回归报告与风险评估。
- PR 检查项（必填）：需求引用、设计影响、测试清单与覆盖率、文档/示例更新、风险与回滚方案。

## 4. 需求与追溯
- 需求 ID：REQ-XXXX；存放 docs/requirements/requirements.md，需含优先级与安全等级。
- RTM：docs/requirements/traceability_matrix.md，映射 Req ↔ Design ↔ Code ↔ Test，PR 必须更新。
- 设计引用：关键模块映射到《整体规划_v3.0_终稿》对应章节与行号。
- 变更：需求变更需提交变更单（影响范围、测试回归计划、回滚方案），审批人=架构师，审阅人=QA。

## 5. 代码规范
- C：C99 + MISRA-C 2012；Cyclomatic <10；所有接口/文件/复杂逻辑需 Doxygen 注释。
- Python：PEP8 基线，类型注解优先；禁止未捕获异常退出工具；命令行工具需提供 `--help` 与退出码。
- 命名：文件小写下划线；类型驼峰+后缀 Type；常量全大写；接口签名与 AUTOSAR 一致；宏前缀使用模块名。
- 结构：遵循分层架构，不跨层直接依赖；公共宏放 utils.h；虚拟OS/配置适配/故障注入保持独立包。
- 禁用：gets/strcpy/sprintf 等不安全 API；禁止裸全局变量；禁止可变长数组。
- 日志：统一使用 logging.c，支持级别控制；测试需可静默运行。

## 6. 构建与 CI 门禁
- 构建：make 或 cmake，默认开启 -Wall -Wextra -Werror --coverage；工具链版本锁定 gcc>=11。
- CI 阶段（全部必过）：
  1) 格式/静态：clang-format 或等效检查、cppcheck（0 Critical/High），MISRA-C 扫描报告。
  2) 编译：全平台构建（含 devcontainer），零警告。
  3) 测试：UT 覆盖率>95%，IT>90%，故障场景 P0/P1 全绿，突变测试杀死率>80%。
  4) 性能：关键基准 <5% 回归（延时、CPU、内存）。
- 未达标处理：PR 需附豁免理由、补救计划，架构师审批，QA 记录技术债。

## 7. 静态 / 动态分析
- 静态：cppcheck --enable=all；lizard 复杂度；clonedigger 重复率；预提交必须通过。
- 动态：valgrind/asan/ubsan 针对内存与未定义行为；故障注入路径需开启 asan+ubsan；性能基线按 perf/*。
- 报告：输出存放 .github/workflows/artefacts 或 docs/qa/，PR 附报告链接。

## 8. 测试策略
- UT：tests/unit，覆盖核心函数与状态转移，语句>95% 分支>90%。
- IT：tests/integration，覆盖跨模块流程（含虚拟OS调度、配置适配、故障注入链路），语句>90% 分支>85%。
- ST：tests/fault + 场景脚本，覆盖全部 REQ，含上下电、WriteAll 一致性、故障恢复、竞态与延迟场景。
- MT：突变测试，杀死率>80%；针对高风险模块（NvM、故障引擎、调度器）。
- 准入：新增功能必须附 UT/IT；故障类特性需对应 P0/P1 场景用例；新增配置解析需附反向兼容测试。

## 9. 文档与示例要求
- API：Doxygen 100% 函数覆盖，输出到 docs/api/，随 CI 发布。
- 教学文档：7 章同步更新，章节对应 design/0x-*.md；涉及《整体规划_v3.0_终稿》章节必须标注引用。
- 示例：examples/ 至少 10 个可编译示例，>100 行、含注释与 README；新增特性需提供最小可复现示例。
- 变更检查表：PR 模板包含“代码/测试/文档/示例/RTM”同步确认项；文档更新需提供截图或链接。

## 10. 安全与合规
- 许可证：MIT；禁止引入不兼容许可证依赖，第三方代码保留原版权声明。
- 依赖审核：新增依赖需列出来源、版本、许可证、用途，经架构师审批，附 SBoM 更新。
- 安全：不提交私钥/令牌；CI 变量使用 GitHub Secret；发布 artefact 禁止包含机密。

## 11. 发布与交付物
- 里程碑输出：
  - 代码：main 分支可构建，CI 全绿，发布 tag。
  - 报告：UT/IT/ST 覆盖率、性能基线、静态/动态分析报告、突变测试结果。
  - 文档：CHANGELOG、API 文档、教学章节、RTM 同步；发布说明含已知问题与风险。
  - 演示：阶段性 demo 或视频（Phase 4 必须），含故障注入与恢复演示。

## 12. 变更管理
- 变更单：包含背景、影响范围、风险、回滚方案、测试计划；存档 docs/changes/，需列 RTM 受影响项。
- 紧急修复：hotfix-*，需在 24h 内补齐测试与文档并合并回 dev/main；发布后 48h 内补充报告。
- 回滚策略：保留上一个通过 CI 的 tag，架构师批准后执行；回滚后需重跑全量 CI 与关键场景。

## 13. 例行审计与度量
- 周度：CI 通过率、覆盖率、复杂度、重复率、缺陷密度；未达标列入技术债清单并指派责任人。
- 里程碑：性能回归、故障场景覆盖（P0=100%，P1≥90%）、RTM 完整性 100%、突变测试杀死率>80%。
- 度量存放：docs/qa/metrics-<week|milestone>.md，QA 维护；关键指标在 README 徽章展示。

---

## 13.1 RTM自动生成与追溯规范（支撑整稿§4.1）

**RTM格式与内容**（docs/requirements/traceability_matrix.md）：
```markdown
| Req ID | 优先级 | 描述 | Design(文件:行) | Code(文件:行) | Unit Test | Integration Test | 状态 |
|--------|--------|------|-----------------|---------------|-----------|-----------------|------|
| REQ-001 | P0 | 支持Native Block读取 | 02-*.md:45 | src/nvm/NvM_Block.c:100-150 | test_nvm_block.c:T_ReadNative | test_read_write_flow.c:T_ReadNative | ✓ PASS |
| REQ-002 | P0 | 虚拟OS调度器支持优先级 | 02-*.md:120 | src/os_shim/scheduler.c:200-300 | test_scheduler.c:T_Priority | test_integration_sched.c:T_Priority | ✓ PASS |
```

**RTM生成工具要求**：
- 脚本语言：Python 3.8+ 或 Bash；应置于 `tools/rtm_generator/`。
- 输入源：
  - `docs/requirements/requirements.md` (Req列表与优先级)
  - 设计文档扫描：design/*.md中的`REQ-xxxx`标记
  - 代码注释扫描：src/*中的`/* REQ-xxxx */`标记与函数范围
  - 测试用例扫描：tests/*中的`test_*`函数与对应Req关联注释
- 输出：
  - `docs/requirements/traceability_matrix.md` (人工可读的追溯表)
  - `docs/requirements/traceability_matrix.json` (机器可读的JSON，含统计)
  - `docs/qa/rtm_coverage_report.md` (覆盖率分析报告)
- 覆盖率检查：
  - REQ完整性：所有REQ需有Design链接（100%）
  - Code完整性：所有REQ需有代码位置链接（100%）
  - Test完整性：所有功能REQ需有UT或IT链接（100%）
  - 故障REQ需有fault test链接（P0=100%, P1≥90%）

**RTM检查点**：
- [ ] RTM生成脚本可一键执行：`python tools/rtm_generator/generate_rtm.py`
- [ ] PR提交时RTM自动检查（CI stage），发现遗漏则PR阻挡
- [ ] 周度度量报告含RTM完整性数据（展示仪表板）
- [ ] 设计/代码/测试文件必须含REQ标记方可合入master

---

## 14. 附录（模板建议）
- PR 模板要素：变更摘要、需求引用、设计影响、测试列表、覆盖率截图/链接、文档/示例/RTM 更新、风险与回滚方案。
- 变更单模板：背景、需求引用、设计影响、测试计划、风险/回滚、审批人、执行人、实施窗口。
- RTM 示例：Req → Design(文件/行) → Code(文件/行) → Test(用例名) → 状态；建议提供自动生成脚本。

## 15. 关键模块编码与测试规范（终稿第2章-关键创新落地）

### 15.1 虚拟OS调度器规范（src/os_shim/）
**设计约束（对应终稿§2.2.A）**：
- 任务模型：支持周期任务（PeriodicTask_t），含优先级、截止期、上下文保存。
- 虚拟时钟精度：±1ms误差内（可配1x/10x/100x/快速模式）；时间倍速不影响相对延迟关系。
- 调度算法：优先级抢占+优先级反转检测；Immediate级任务可抢占同级。
- 延迟模拟：支持任务延迟注入（最差情况：NvM_MainFunction延迟50ms），需配置化。
- 中断模拟：单层中断（ISR优先级>任务），Hook点需Doxygen标注。

**编码规范**：
```c
// src/os_shim/os_scheduler.h
typedef struct {
    TaskId_t task_id;
    uint32_t period_ms;         // 周期（毫秒）
    uint8_t priority;            // 0=最高，255=最低
    void (*task_func)(void);     // 任务函数指针
    uint32_t deadline_ms;        // 截止期（可选，0=无约束）
    uint32_t max_exec_time_us;   // 最大执行时间（用于监控）
} OsTask_t;

// API约定（Phase 1出口需实现）
typedef Std_ReturnType (*OsScheduler_RegisterTask)(const OsTask_t *task);
typedef Std_ReturnType (*OsScheduler_UnregisterTask)(TaskId_t task_id);
typedef void (*OsScheduler_SetTimeScale)(uint16_t scale);  // 1/10/100/65535(最快)
typedef uint32_t (*OsScheduler_GetVirtualTimeMs)(void);
```

**测试要求**：
- UT：任务注册、优先级排序、时间倍速、延迟注入各有独立用例（≥10个）。
- IT：与NvM_MainFunction的交互（任务调度vs Job队列处理），优先级反转场景。
- Perf：调度开销<2%，100+任务无栈溢出。

**评审检查点**：
- [ ] 虚拟时钟实现了3种时间倍速模式（1x/10x/100x）。
- [ ] 任务延迟最多支持50ms（对应等待NvM处理）。
- [ ] 中断模拟接口Doxygen文档完整。
- [ ] 相关UT覆盖率>90%，IT覆盖关键路径（WriteAll与调度竞争）。

---

### 15.2 故障注入框架规范（src/eeprom/fault_injection.*）
**设计约束（对应终稿§2.2.C）**：
- 故障库：30+预定义故障场景（P0/P1/P2），覆盖终稿§9.2的故障矩阵表。
- Hook机制：在Eep_Write/Eep_Read/Crc_Calculate关键点埋装饰器回调。
- 插件化：故障逻辑与功能逻辑完全解耦，支持用户自定义故障插件（接口导出）。
- 配置化：支持故障启用/禁用、参数动态调整（无需重编译），记录诊断信息。
- 可观测性：每个故障注入需记录触发条件、故障发生时刻、恢复结果。

**编码规范**：
```c
// src/eeprom/fault_injection.h
typedef Std_ReturnType (*FaultHook_t)(
    const char *operation,      // "Eep_Write", "Eep_Read", "Crc_Calculate"
    void *context,              // 操作上下文（如偏移、数据指针）
    void *fault_params          // 故障参数指针
);

typedef struct {
    const char *fault_id;       // "PowerLoss_At_Page_3", "BitFlip_Random"
    FaultHook_t hook_func;      // 故障处理函数
    uint8_t is_enabled;         // 故障启用标志
    uint32_t trigger_count;     // 触发计数（诊断）
    uint32_t recover_count;     // 恢复计数（诊断）
} FaultPlugin_t;

// 预定义故障库API（Phase 3出口需实现P0/P1全集）
typedef Std_ReturnType (*FaultInj_RegisterPlugin)(const FaultPlugin_t *plugin);
typedef Std_ReturnType (*FaultInj_EnableFault)(const char *fault_id);
typedef Std_ReturnType (*FaultInj_DisableFault)(const char *fault_id);
typedef void (*FaultInj_GetDiagnostics)(FaultDiag_t *diag_out);  // 导出诊断信息
```

**故障库清单（最小必需）**：
| ID | 等级 | 故障 | Hook点 | 触发条件配置 | Phase入库 |
|----|------|------|-------|----------|--------|
| FI_PowerLoss_Write | P0 | 写入掉电 | Eep_Write结束 | offset范围 | Phase 3 |
| FI_BitFlip_Random | P0 | 随机位翻转 | Eep_Read结束 | 翻转率(0-7bit) | Phase 3 |
| FI_Timeout_50ms | P0 | 操作超时 | 任意操作 | 超时时长 | Phase 3 |
| FI_CRC_Invert | P1 | CRC反转 | Crc_Calculate结束 | Block ID | Phase 3 |
| FI_WriteVerify_Fail | P1 | 写入验证失败 | 验证阶段 | 失败率 | Phase 3 |
| FI_RaceCondition_CAS | P2 | 原子操作失败 | 读写竞争 | 冲突概率 | Phase 4 |

**测试要求**：
- UT：每个故障插件至少5个测试（注入、诊断导出、启用禁用等）。
- IT：故障注入链路验证（Hook →行为修改→恢复判断）。
- ST/Fault：P0故障用例100%通过，P1故障用例≥90%通过（见终稿§9.2）。
- Perf：故障注入开销<2%（vs无注入情况）。

**评审检查点**：
- [ ] 至少实现了10个预定义故障（P0类4个以上）。
- [ ] Hook机制在关键路径（Eep_Write/Read/Crc）都有埋点。
- [ ] 故障启用/禁用可动态配置（支持脚本与CLI）。
- [ ] 诊断导出接口完整（触发计数、恢复率、失败日志）。
- [ ] 相关UT/IT覆盖率>90%，ST覆盖对应故障场景。

---

### 15.3 配置适配工具规范（tools/config_gen/）
**设计约束（对应终稿§2.2.B）**：
- 双路适配：DSL路径（.cfg格式，初学者友好）与ARXML路径（工业标准）都支持。
- DSL编译：.cfg → NvM_Cfg.c/h，支持配置校验、代码生成、MISRA-C检查。
- ARXML解析：XML → Block描述提取 → NvM_Cfg.c/h生成，支持XPath查询与反向兼容。
- 输出质量：生成代码需通过cppcheck、MISRA-C、编译无警告。
- 版本跟踪：生成的配置文件需包含生成器版本与时间戳。

**编码规范**：
```python
# tools/config_gen/dsl_compiler.py
"""
DSL编译规范（Phase 2出口需支持）
输入格式：.cfg文本（类似Kconfig）
输出：NvM_Cfg.c/h + 配置验证报告
"""
class DslCompiler:
    def parse_config(self, cfg_path: str) -> ConfigModel:
        """解析.cfg文件，返回配置模型"""
        pass
    
    def validate(self, config: ConfigModel) -> ValidationResult:
        """验证配置完整性、一致性"""
        # 检查项：Block ID唯一、CRC类型有效、Size在范围内等
        pass
    
    def codegen(self, config: ConfigModel, output_dir: str) -> bool:
        """生成C代码，通过后返回True"""
        # 输出NvM_Cfg.h和NvM_Cfg.c
        pass
```

```python
# tools/config_gen/arxml_parser.py
"""
ARXML解析规范（Phase 4出口需支持）
输入：AUTOSAR .arxml片段（NvMBlockDescriptor节点）
输出：Block配置模型 → NvM_Cfg.c/h
"""
class ArxmlParser:
    def parse_arxml(self, arxml_path: str) -> ConfigModel:
        """XPath查询提取NvMBlockDescriptor"""
        # 提取：BlockId, BlockSize, CrcType, Redundancy, Priority等
        pass
    
    def validate_arxml(self, arxml_path: str) -> ValidationResult:
        """ARXML约束检查"""
        # 检查必填字段、类型有效性、与本项目兼容性
        pass
    
    def to_config_model(self, arxml: ElementTree) -> ConfigModel:
        """ARXML → 配置模型转换"""
        pass
```

**输出验证规范**：
- 生成代码必须通过：`cppcheck --enable=all`，0 Critical/High。
- MISRA-C检查：MISRA必选规则100%通过，建议≥90%。
- 编译检查：`gcc -Wall -Wextra -Werror` 无警告。
- 格式检查：代码风格符合项目规范（Doxygen注释、命名约定等）。

**测试要求**：
- UT：DSL解析、ARXML解析、配置验证各≥5个用例；包含无效输入、边界情况。
- IT：端到端流程（.cfg/.arxml → 生成 → 编译 → 执行冒烟）。
- 配置库：tools/config_gen/testdata/ 包含simple/real_world/stress三个配置用例。

**评审检查点**：
- [ ] DSL编译器支持基本配置生成（Phase 2）。
- [ ] ARXML解析器支持NvMBlockDescriptor提取（Phase 4）。
- [ ] 生成代码通过cppcheck与MISRA检查。
- [ ] 端到端流程验证通过（配置→编译→运行）。
- [ ] 相关UT覆盖率>90%。

---

### 15.4 分层学习认证规范（对应终稿§8，学习路径保障）
**学习路径与技能认证**（见终稿§8.1-8.3）：

| 路径 | 时长 | 目标人群 | 学习内容 | 认证标准 | 验收方式 |
|-----|------|--------|--------|---------|--------|
| **快速路径** | 3天 | 初学者/学生 | 第1章(EEPROM基础)+第2章核心+第5章ex1-4 | 5道综合题,≥80%通过 | 在线题库/答题卡 |
| **标准路径** | 1周 | 工程师/新手 | 第1-5章完整+实战作业 | 10道题库,≥80%;完成1个2-Block系统设计 | 代码审查+题库 |
| **专家路径** | 3周 | 资深工程师 | 全部7章+故障诊断+ARXML适配 | 20道题库+故障诊断5场景+贡献代码 | 综合考试+代码贡献 |

**学习路径与文档对应**：
- 快速路径：→ design/01-*.md + examples/basic/{ex01-04} → docs/tutorials/QUICK_START.md
- 标准路径：→ design/01-05-*.md + examples/{basic,advanced} → docs/tutorials/LEARNING_PATHS.md
- 专家路径：→ design/全部 + examples/fault_scenarios + 故障库贡献 → docs/tutorials/EXPERT_GUIDE.md

**认证执行规范**（Phase 4后启用）：
- 快速路径认证：5道单选+填空题，限时30分钟，自动评分，云题库。
- 标准路径认证：10道题+1个开放式设计，人工审查，反馈周期<3天。
- 专家路径认证：综合考试(笔试)+代码审查(贡献补丁至少100行)，评审周期<1周。
