# 04-数据完整性方案

> **目标**：定义CRC校验、冗余存储、RAM镜像、写入验证等数据保护机制，以及故障恢复决策树与性能权衡分析。  
> **适用读者**：核心开发(Phase 2-3) / 测试(Phase 3)。  
> **本章对标**：终稿§3「教学内容规划」第四章，以及终稿§5「质量保障体系」§9「故障库」。  
> **输出物**：
> - CRC选型对比表与配置指南
> - 冗余与镜像机制的完整说明
> - 故障恢复决策树(完整的恢复策略)
> - 写入验证流程
> - 性能与可靠性权衡表与测试方案
> - 恢复时间(MTTR)与数据丢失率指标
> - RTM钩子（REQ-数据完整性与故障恢复）

## 1. CRC校验策略

### 1.1 CRC类型选择指南

**CRC8 vs CRC16 vs CRC32 对比**：

| 维度 | CRC8 | CRC16 | CRC32 |
|-----|------|--------|--------|
| **多项式** | 0x07 或 0x9B | 0x1021(标准) | 0x04C11DB7 |
| **计算时间** | 最快 | 中等 | 较慢 |
| **覆盖数据范围** | 1字节 | 256字节 | 4GB |
| **漏检率**(随机错误) | 1/256 | 1/65536 | 1/4B |
| **应用场景** | 小Block(<64B) | 中等Block(64-1024B) | 大Block(>1024B) 或关键数据 |
| **汽车应用典型** | 不常用 | 常见(标准) | 关键数据(VIN/配置) |

**选型决策表**：

```
Block Size ≤ 64B  → CRC8 (开销 <0.5%)
Block Size 64-512B → CRC16 (开销 <1%)
Block Size >512B  → CRC32 (开销 <2%)

或按可靠性要求:
普通数据(容错) → CRC16
关键数据(VIN/配置) → CRC32
高可靠应用 → CRC32 + Redundancy
```

### 1.2 CRC覆盖范围与配置

**可保护的内容**：
```c
typedef struct {
    uint8_t block_data[256];        // ← CRC覆盖范围(必须)
    
    // 可选:
    uint8_t block_id;               // ← CRC可包含元数据
    uint8_t version;                // ← 
    uint16_t stored_crc;            // ← CRC本身不包含在计算中
} NvM_BlockWithMetadata_t;

// CRC计算范围配置:
// 选项1: 仅数据 CRC = Crc_Calculate(block_data, 256)
// 选项2: 数据+元数据 CRC = Crc_Calculate(block_id|version|block_data, 258)
```

**AUTOSAR规范**（SWS-NvM §9.2.2）：
- 标准做法：CRC覆盖Block数据+Block ID
- 好处：防止Block ID错误导致的数据混淆

### 1.3 CRC开销估算

**性能计算公式**：
```
T_crc = k * block_size / cpu_freq

其中 k 是常数(取决于算法):
  CRC8:  k ≈ 5-10 cycles/byte
  CRC16: k ≈ 10-15 cycles/byte  
  CRC32: k ≈ 15-20 cycles/byte

例：CPU 16MHz, Block 256B, CRC16
  T_crc = 12 * 256 / 16M ≈ 0.19ms ≈ 0.2% of 10ms Task周期
```

**虚拟仿真中的CRC延时模拟**：
```c
// src/nvm/NvM_DataIntegrity.c
uint32_t Crc_Calculate_WithDelay(const uint8_t *data, uint16_t length) {
    uint32_t crc = 0;
    
    // 实际CRC计算
    for (int i = 0; i < length; i++) {
        crc = CrcTable[(crc ^ data[i]) & 0xFF] ^ (crc >> 8);
    }
    
    // 模拟CPU执行延迟(可配置)
    // T_delay = (length * cycles_per_byte) / cpu_freq_mhz
    VirtualTime_SimulateDelay(length * 12 / CPU_FREQ_MHZ);  // CRC16
    
    return crc;
}
```

## 2. 冗余存储与RAM镜像机制

### 2.1 概念澄清：冗余块 vs RAM镜像

**常见混淆**：
- ❌ 错误：认为冗余块=RAM镜像
- ✅ 正确：冗余块是EEPROM中的双副本，RAM镜像是内存缓存

**冗余块（Redundant Block）**：
```
EEPROM中的结构：
┌────────────────────────────────┐
│ Primary Block (256B + CRC)     │  ← 主副本
├────────────────────────────────┤
│ Backup Block (256B + CRC)      │  ← 备份副本
├────────────────────────────────┤
│ Redundancy Control Block (4B)  │  ← 版本号/标志
└────────────────────────────────┘

作用：当主副本CRC失败时，可切换到备份副本
```

**RAM镜像（RAM Mirror）**：
```
内存中的结构：
┌──────────────────────────────┐
│ RAM Mirror (256B)            │  ← 应用读写的内存缓存
│ 对应EEPROM中的某个Block     │
└──────────────────────────────┘

作用：
1. 应用高频读写RAM而非EEPROM(快速)
2. WriteBlock/WriteAll时将RAM数据刷写到EEPROM
3. ReadBlock/ReadAll时将EEPROM数据读到RAM
```

**关系图**：
```
应用修改 RAM Mirror
  ↓
NvM_WriteBlock()
  ├─ 读取 RAM Mirror
  ├─ 若为Redundant Block: 
  │  ├─ 写主副本到EEPROM
  │  ├─ 验证(CRC)
  │  └─ 更新版本号,标记主副本为最新
  └─ 返回Job完成

下次NvM_ReadBlock()
  ├─ 从EEPROM读主副本
  ├─ CRC失败 → 尝试备份
  ├─ 成功 → 更新RAM Mirror
  └─ 应用读取更新后的RAM Mirror
```

### 2.2 冗余存储的写入策略

**策略：主→备，验证后标记**（SWS-NvM 9.2.3推荐）：

```c
// src/nvm/NvM_BlockManagement.c

Std_ReturnType NvM_WriteRedundantBlock(
    const NvM_BlockConfigType *block,
    const uint8_t *data) {
    
    // Step 1: 写主副本
    MemIf_Write(block->primary_eeprom_offset, data, block->size);
    
    // Step 2: 计算CRC
    uint16_t new_crc = Crc_Calculate(data, block->size);
    
    // Step 3: 写CRC到主副本的CRC字段
    MemIf_Write(block->primary_eeprom_offset + block->size, 
                &new_crc, sizeof(new_crc));
    
    // Step 4: 验证主副本(读回验证)
    uint8_t read_buffer[256];
    MemIf_Read(block->primary_eeprom_offset, read_buffer, block->size);
    uint16_t verify_crc = Crc_Calculate(read_buffer, block->size);
    
    if (verify_crc != new_crc) {
        LOG_ERROR("主副本写入验证失败!");
        // 不更新版本号,下次读取仍使用备份
        return E_NOT_OK;
    }
    
    // Step 5: 更新版本号(标记主副本为最新)
    uint8_t version = ReadRedundancyVersion(block) + 1;
    MemIf_Write(block->redundancy_control_offset, &version, 1);
    
    // Step 6: 可选:也更新备份副本(慢,但更安全)
    // MemIf_Write(block->backup_eeprom_offset, data, block->size);
    
    return E_OK;
}
```

**读冗余块时的选择策略**：

```c
Std_ReturnType NvM_ReadRedundantBlock(
    const NvM_BlockConfigType *block,
    uint8_t *out_buffer) {
    
    // 读取版本号
    uint8_t primary_version = ReadRedundancyVersion(block);
    uint8_t backup_version = ReadBackupRedundancyVersion(block);
    
    if (primary_version >= backup_version) {
        // 主副本更新,尝试主副本
        if (TryReadBlock(block->primary_eeprom_offset, out_buffer, block->size)) {
            return E_OK;  // 主副本成功
        }
        // 主副本失败,回退到备份
        if (TryReadBlock(block->backup_eeprom_offset, out_buffer, block->size)) {
            return E_OK;  // 备份成功
        }
        // 两者都失败
        return E_NOT_OK;
    } else {
        // 备份更新,尝试备份副本
        if (TryReadBlock(block->backup_eeprom_offset, out_buffer, block->size)) {
            return E_OK;
        }
        if (TryReadBlock(block->primary_eeprom_offset, out_buffer, block->size)) {
            return E_OK;
        }
        return E_NOT_OK;
    }
}

bool TryReadBlock(uint32_t offset, uint8_t *buffer, uint16_t size) {
    MemIf_Read(offset, buffer, size);
    uint16_t read_crc = Read_CRC_FromEeprom(offset + size);
    uint16_t calc_crc = Crc_Calculate(buffer, size);
    return (read_crc == calc_crc);
}
```

### 2.3 RAM镜像与同步机制

**镜像管理**：
- 镜像刷新点：ReadAll(启动)、ReadBlock(显式)、WriteBlock完成后
- 镜像脏标志：追踪RAM是否已修改且未同步EEPROM(见第3章)

**最佳实践**：
```c
// 应用初始化时：读取EEPROM到RAM镜像
NvM_ReadAll();          // 启动一致性
while (NvM_GetJobResult(...) == PENDING) {}  // 等待

// 应用运行时：修改RAM
app_ram_block_0.value = new_value;    // 修改RAM镜像

// 需要保存时：写回EEPROM
NvM_WriteBlock(BLOCK_0);   // 刷写RAM到EEPROM
```

## 3. 故障恢复与降级流程

### 3.1 完整故障恢复决策树

```
Block读出 (ReadBlock或ReadAll)
  ↓
计算CRC
  ↓
CRC校验 ┬─ ✓ 通过 ──→ 返回Block_OK,更新RAM镜像
        │
        └─ ✗ 失败 ──→ 进入RECOVERING
           │
           ├─ [步骤1] 检查冗余配置
           │  ├─ 若Block类型=Redundant
           │  │  ├─ 读取冗余块
           │  │  ├─ 计算冗余块CRC
           │  │  ├─ ✓ 冗余块成功 → 返回Block_OK (恢复成功)
           │  │  └─ ✗ 冗余块也失败 → 进入[步骤2]
           │  │
           │  └─ 若Block类型≠Redundant → 进入[步骤2]
           │
           ├─ [步骤2] 检查Dataset版本回退
           │  ├─ 若Block类型=Dataset
           │  │  ├─ 查询所有版本的CRC状态
           │  │  ├─ ✓ 找到有效版本 → 返回Block_OK (版本回退成功)
           │  │  └─ ✗ 所有版本都损坏 → 进入[步骤3]
           │  │
           │  └─ 若Block类型≠Dataset → 进入[步骤3]
           │
           ├─ [步骤3] 加载默认值或ROM初值
           │  ├─ 若Block配置了ROM初值 → 返回Block_INCONSISTENT (数据已改变)
           │  └─ 若Block无ROM初值 → 返回Block_INVALID (数据丢失)
           │
           └─ [最终] 返回应用,供应用决定是否继续或降级
```

### 3.2 降级策略（性能与可靠性权衡）

**可选的降级措施**（在故障发生时）：
```c
typedef enum {
    DEGRADATION_NONE = 0,               // 无降级,继续正常操作
    DEGRADATION_SKIP_CRC = 1,           // 跳过CRC校验(风险↑)
    DEGRADATION_DISABLE_REDUNDANCY = 2, // 禁用冗余检查(可靠性↓)
    DEGRADATION_READONLY = 3,           // 只读模式(无新写入)
    DEGRADATION_CRITICAL_HALT = 4,      // 暂停处理,等待诊断
} DegradationMode_t;
```

**应用层降级决策示例**：
```c
void app_handle_block_recovery(uint16_t block_id, RecoveryResult_t result) {
    switch (result) {
    case RECOVERY_SUCCESS:
        return;  // 正常
        
    case RECOVERY_FROM_REDUNDANCY:
        DiagService_ReportWarning("Block %d冗余恢复", block_id);
        return;  // 可继续运行
        
    case RECOVERY_FROM_ROM:
        if (block_id == BLOCK_VIN) {
            DiagService_SetDtc(DTC_VIN_DATA_DEGRADED);
            system_degradation_mode = DEGRADATION_READONLY;
        }
        return;
        
    case RECOVERY_FAILED:
        LOG_CRITICAL("Block %d数据丢失,进入SafeMode", block_id);
        system_degradation_mode = DEGRADATION_CRITICAL_HALT;
        return;
    }
}
```

## 4. 性能与可靠性权衡

### 4.1 影响维度与量化指标

| 维度 | CRC16 vs None | Redundancy vs Single | RAM Mirror vs Direct |
|-----|---------------|---------------------|----------------------|
| **延迟增加** | +1-2% | +30-40% (写) | -50% (读) |
| **空间增加** | +0.6% | +100% | +100% (RAM) |
| **CPU开销** | +1% | +3% (版本管理) | +2% (同步) |
| **可靠性改进** | ✓✓ (检测漏错) | ✓✓✓ (故障恢复) | ✓ (一致性) |

### 4.2 决策表：按Block重要度选择保护策略

| Block类型 | 示例 | CRC | Redundancy | RAM Mirror | 备注 |
|----------|------|-----|------------|-----------|------|
| **关键** | VIN, 配置 | CRC32 | ✓ | ✓ | 最高可靠性 |
| **重要** | 里程表, DTC | CRC16 | ✓ | ✓ | 冗余+镜像 |
| **普通** | 用户设置 | CRC16 | - | ✓ | 镜像同步 |
| **低频** | 校准数据 | CRC8 | - | - | 基础CRC |

### 4.3 性能测试方案（v1.0交付）

**关键测试用例** (perf/):
- `perf_crc_overhead.c`: CRC8/16/32延迟对比
- `perf_redundancy_overhead.c`: 冗余写入开销(双写、版本管理)
- `perf_ram_mirror_sync.c`: RAM镜像同步周期性能

**预期结果** (基线设定):
- WriteBlock(无冗余): <20ms
- WriteBlock(冗余): <30ms (可接受<5%回归)
- ReadBlock(从缓存): <5ms
- CRC16计算: <1ms per 256B Block

## 5. 写入验证机制（AUTOSAR标准）

### 5.1 写入验证流程

**标准做法** (SWS-NvM §9.2.3):
```c
// 写入流程:
1. 计算新数据的CRC
2. 写入新数据到EEPROM
3. 写入新CRC到EEPROM
4. [关键步骤] 读回验证:
   - 从EEPROM重新读取数据
   - 重新计算CRC
   - 对比写入前后的CRC是否一致
5. 若验证成功→返回BLOCK_OK
6. 若验证失败→重试或标记失败
```

**虚拟实现**:
```c
Std_ReturnType NvM_WriteAndVerify(
    const NvM_BlockConfigType *block,
    const uint8_t *data) {
    
    // Step 1: 计算CRC
    uint16_t new_crc = Crc_Calculate(data, block->size);
    
    // Step 2: 写入
    MemIf_Write(block->eeprom_offset, data, block->size);
    MemIf_Write(block->eeprom_offset + block->size, &new_crc, 2);
    
    // Step 3: [故障注入Hook] 模拟掉电中断、位翻转等
    FaultInj_HookAfterWrite(block->block_id);
    
    // Step 4: 读回验证
    uint8_t read_buffer[256];
    MemIf_Read(block->eeprom_offset, read_buffer, block->size);
    uint16_t verify_crc = Crc_Calculate(read_buffer, block->size);
    
    // Step 5: 验证结果
    if (verify_crc != new_crc) {
        LOG_ERROR("Block %d写入验证失败!", block->block_id);
        
        // 重试逻辑(最多3次)
        if (retry_count++ < 3) {
            return NvM_WriteAndVerify(block, data);  // 重试
        }
        
        // 冗余切换(若有)
        if (block->block_type == NVM_BLOCK_REDUNDANT) {
            LOG_WARN("尝试备份副本");
            return NvM_WriteRedundantBlock(block, data);
        }
        
        return E_NOT_OK;  // 写入失败
    }
    
    return E_OK;  // 验证成功
}
```

## 6. 验证与度量

### 6.1 覆盖率目标 (v1.0)

**单元测试**:
- CRC8/16/32算法正确性: >95%
- 冗余块读写逻辑: >90%
- 故障恢复决策树: >85% (涵盖主要路径)

**集成测试**:
- 故障库F01-F05的恢复流程: 100%验证
- 性能基准: 写入验证延迟<5%回归

### 6.2 RTM追溯

```
REQ-数据完整性方案:
├─ REQ-CRC校验: 1.1-1.3章 → src/utils/crc_algorithm.c
├─ REQ-冗余存储: 2.1-2.3章 → src/nvm/NvM_BlockManagement.c
├─ REQ-故障恢复: 3.1-3.2章 → src/nvm/NvM_DataIntegrity.c
├─ REQ-RAM镜像一致性: 2.3章 → src/nvm/NvM_SyncMechanism.c
├─ REQ-写入验证: 5.1章 → src/nvm/NvM_WriteAndVerify.c
└─ REQ-性能基准: 4.3章 → tests/perf/perf_*.c
```
