# 05-使用示例与最佳实践

> **目标**：提供10+完整可编译示例，覆盖快速路径/标准路径/专家路径的学习需求，附带运行验证、常见陷阱说明。  
> **适用读者**：快速/标准/专家学习路径的学员。  
> **本章对标**：终稿§3「教学内容规划」第五章，以及§8「多条学习路径」。  
> **输出物**：
> - 10+示例程序清单(>100行代码,含注释)
> - 示例分层(入门/进阶/故障)
> - 运行与验证脚本(run_all_examples.sh)
> - 常见陷阱与对策说明
> - 预期输出与日志样例
> - RTM钩子(REQ-功能与故障教学)

## 1. 示例程序分层与清单

### 1.1 快速路径示例（难度⭐⭐，学习时间1-2天）

| 示例 | 文件 | 代码行 | 学习目标 | 前置条件 |
|------|------|--------|--------|--------|
| ex01 | single_block_read.c | 150 | NvM_ReadBlock基础 | 第1-2章完成 |
| ex02 | single_block_write.c | 180 | NvM_WriteBlock基础 | ex01完成 |
| ex03 | explicit_sync.c | 120 | 显式同步(ReadBlock+WriteBlock) | ex01-02完成 |
| ex04 | implicit_sync.c | 200 | 隐式同步(ReadAll+WriteAll) | ex03完成 |

**运行指南**（快速路径认证）：
```bash
cd examples/basic
make all                                    # 编译所有示例
./run_basic_examples.sh                     # 运行示例
# 预期输出：4个示例都通过，总耗时<1秒(10X倍速)
```

**学习检查点**：
- [ ] 理解NvM异步机制(Job队列)
- [ ] 能解释状态机转移(IDLE→READING→VERIFY→IDLE)
- [ ] 理解ReadAll在启动时的一致性作用

### 1.2 标准路径示例（难度⭐⭐⭐，学习时间2-3天）

| 示例 | 文件 | 代码行 | 学习目标 | 前置条件 |
|------|------|--------|--------|--------|
| ex05 | redundant_block.c | 250 | Redundant Block双副本 | 快速4个例 |
| ex06 | dataset_block.c | 220 | Dataset Block版本管理 | ex05完成 |
| ex07 | multiple_blocks.c | 300 | 多Block协调(优先级/队列) | ex06完成 |
| ex08 | priority_jobs.c | 280 | Job优先级与抢占 | ex07完成 |
| ex09 | crc_verification.c | 200 | CRC校验与失败恢复 | ex08完成 |
| ex10 | power_cycle.c | 350 | 完整上下电流程 | ex09完成 |

**运行指南**（标准路径认证）：
```bash
cd examples/advanced
make all
./run_advanced_examples.sh
# 预期输出：6个示例都通过，总耗时<3秒(10X倍速)
```

**学习检查点**：
- [ ] 掌握冗余块与备份切换机制
- [ ] 理解版本管理与Dataset选择最新版本的逻辑
- [ ] 能设计多Block系统的一致性保证
- [ ] 理解WriteAll两阶段提交机制

### 1.3 专家路径示例（难度⭐⭐⭐⭐⭐，学习时间3-4天）

| 示例 | 文件 | 代码行 | 学习目标 | 前置条件 |
|------|------|--------|--------|--------|
| fault_power_loss | power_loss_recovery.c | 400 | 掉电恢复(FI_PowerLoss_Write) | 标准6个例 |
| fault_bit_flip | bit_flip_detection.c | 350 | 位翻转恢复(FI_BitFlip_Random) | fault_power_loss |
| fault_multi_block | multi_block_failure.c | 380 | 多Block故障处理 | fault_bit_flip |
| fault_race_condition | race_condition_sim.c | 320 | 竞态条件与RAM一致性 | fault_multi_block |

**运行指南**（专家路径认证）：
```bash
cd examples/fault_scenarios
make all
./run_fault_scenarios.sh                    # 需激活故障注入模式
# 预期输出：故障被正确注入、检测、恢复,系统保持一致
```

**学习检查点**：
- [ ] 理解掉电原子性与Page级对齐
- [ ] 掌握故障恢复决策树(冗余→ROM→默认)
- [ ] 能诊断并处理RAM-EEPROM竞态
- [ ] 理解虚拟OS调度对故障的影响

## 2. 运行与验证

### 2.1 全量示例执行脚本

**脚本：examples/run_all_examples.sh**
```bash
#!/bin/bash

set -e  # 任何命令失败则停止

echo "==== eepromSim示例运行脚本 ===="
echo "运行环境：虚拟时间倍速=10X(加速测试)"

# 第1阶段：快速路径示例
echo "[Phase 1] 快速路径示例 (4个) ..."
cd examples/basic
make clean && make
for example in ex01 ex02 ex03 ex04; do
    echo "  运行 $example ..."
    ./$example
done
echo "✓ 快速路径全部通过"

# 第2阶段：标准路径示例
echo "[Phase 2] 标准路径示例 (6个) ..."
cd ../advanced
make clean && make
for example in ex05 ex06 ex07 ex08 ex09 ex10; do
    echo "  运行 $example ..."
    ./$example
done
echo "✓ 标准路径全部通过"

# 第3阶段：故障场景示例(仅在故障注入启用时运行)
echo "[Phase 3] 故障场景示例 (4个) ..."
cd ../fault_scenarios
make clean && make ENABLE_FAULT_INJECTION=1
for example in fault_power_loss fault_bit_flip fault_multi_block fault_race_condition; do
    echo "  运行 $example ..."
    ./$example
done
echo "✓ 故障场景全部通过"

echo ""
echo "==== 全量示例执行完成 ===="
echo "总耗时：<5秒 (10X倍速)"
```

**执行效果**：
```
==== eepromSim示例运行脚本 ====
[Phase 1] 快速路径示例 (4个) ...
  运行 ex01 ...
[NvM] Init completed
[NvM] ReadBlock(Block_0) submitted
[Job] Block_0 reading: ... CRC OK
[Block_0] Data: 0x11 0x22 0x33 ...
✓ ex01 passed

  运行 ex02 ...
...
✓ 快速路径全部通过
```

### 2.2 预期输出与日志样例

**示例ex02_single_block_write的预期输出**：
```
[NvM] NvM_Init()
[NvM] Initializing 4 blocks

[App] Writing config block (Block_0, 256B)
[NvM] WriteBlock(Block_0) submitted, Job queued

[Scheduler] NvM_MainFunction tick 10ms
[NvM] Processing WriteBlock(Block_0)
[NvM] State: WRITING
  ├─ MemIf_Write(offset=0x000, size=256)
  ├─ Virtual delay simulated: 2ms
  └─ Write completed

[NvM] State: WRITE_VERIFY
  ├─ Reading back for verification
  ├─ CRC16: 0x1A2B calculated
  ├─ CRC16: 0x1A2B stored (match!)
  └─ Verification passed

[NvM] Job completed, state=OK
[NvM] Invoking callback: JobEndNotification(Block_0)

[App] WriteBlock completed successfully!
[Diagnostics]
  - Blocks written: 1
  - CRC verifications: 1 (1 passed)
  - Redundancy switches: 0
```

### 2.3 常见陷阱与对策

**陷阱1：忘记检查Job状态**
```c
// ❌ 错误
NvM_WriteBlock(Block_0, data);
// 立即访问EEPROM,但写入可能还在进行!

// ✅ 正确
NvM_WriteBlock(Block_0, data);
while (NvM_GetJobResult(Block_0) == NVM_REQ_PENDING) {
    NvM_MainFunction();  // 驱动Job执行
}
// 现在Block_0已安全写入
```

**陷阱2：Block大小不一致**
```c
// ❌ 错误
uint8_t buffer[128];
NvM_ReadBlock(BLOCK_CONFIG, buffer);  // BLOCK_CONFIG定义为256B
// 缓冲溢出风险！

// ✅ 正确
#define BUFFER_SIZE NVM_BLOCK_CONFIG_SIZE  // 从配置获取
uint8_t buffer[BUFFER_SIZE];
NvM_ReadBlock(BLOCK_CONFIG, buffer);
```

**陷阱3：CRC配置不匹配**
```c
// ❌ 错误
// NvM_Cfg.c: Block_0 CRC type = CRC16
// 应用代码: Crc_Calculate(data, 256, CRC32)  // 类型不匹配
// 结果：校验总是失败

// ✅ 正确
// 应用代码: 使用配置中定义的CRC类型
Crc_Calculate(data, 256, nvm_config[BLOCK_0].crc_type);
```

**陷阱4：WriteAll期间修改RAM**
```c
// ❌ 错误
NvM_WriteAll();
app_config.version++;          // WriteAll执行中修改RAM
// 结果：脏数据,EEPROM内容不一致

// ✅ 正确
// 关机前停止所有修改任务
App_StopModifyingRam();
HAL_SyncWaitMs(10);
NvM_WriteAll();                // 此时RAM稳定
```

## 3. RTM钩子与学习认证

### 3.1 例子与设计需求映射

| 学习路径 | 例子号 | 程序位置 | 涉及设计 | 验证测试 | 认证考点 |
|--------|--------|---------|--------|---------|----------|
| Quick | ex01 | examples/basic/ex01_single_read.c | 02§1+2 | tests/unit/test_api_read.c | 理解ReadBlock异步API |
| Quick | ex02 | examples/basic/ex02_single_write.c | 02§2.1+04§5 | tests/unit/test_api_write.c | 理解WriteBlock写流程 |
| Quick | ex03 | examples/basic/ex03_explicit_sync.c | 03§1.1 | tests/integration/test_explicit_sync.c | Native Block显式同步 |
| Quick | ex04 | examples/basic/ex04_implicit_sync.c | 03§1.2 | tests/integration/test_implicit_sync.c | ReadAll/WriteAll隐式同步 |
| Standard | ex05 | examples/advanced/ex05_redundant_block.c | 03§1.2+04§2 | tests/unit/test_redundant_type.c | Redundant Block冗余机制 |
| Standard | ex06 | examples/advanced/ex06_dataset_block.c | 03§1.3 | tests/unit/test_dataset_type.c | Dataset多版本管理 |
| Standard | ex07 | examples/advanced/ex07_multi_blocks.c | 02§4+03§4 | tests/integration/test_priority_queue.c | 多Block优先级队列调度 |
| Standard | ex08 | examples/advanced/ex08_priority_preemption.c | 02§4.3 | tests/integration/test_priority_preemption.c | 虚拟OS优先级抢占 |
| Standard | ex09 | examples/advanced/ex09_crc_recovery.c | 04§1+§3 | tests/system/test_crc_recovery.c | CRC失败与恢复决策 |
| Standard | ex10 | examples/advanced/ex10_power_cycle.c | 04§3 | tests/system/test_power_cycle_sim.c | 掉电恢复仿真 |
| Expert | fault01 | examples/fault/fault01_power_loss.c | 01§4+04§3 | tests/system/test_p0_powerloss.c | P0级故障注入与恢复 |
| Expert | fault02 | examples/fault/fault02_bit_flip.c | 01§4+04§1 | tests/system/test_p0_bitflip.c | P0级数据翻转与CRC |
| Expert | fault03 | examples/fault/fault03_multi_block_fail.c | 01§4+02§4 | tests/system/test_p1_multiblock.c | P1级并发故障处理 |
| Expert | fault04 | examples/fault/fault04_race_condition.c | 01§4+03§3 | tests/system/test_p2_race.c | P2级竞态条件覆盖 |

### 3.2 认证标准

**Quick认证** (5选1，80分通过)：理解NvM基础API和Block类型
- 参考代码: examples/basic/{ex01-ex04}
- 认证题库: docs/quiz/quick_quiz.md (5道题，10分钟)
- 通过后获得: eepromSim Quick Learner Badge

**Standard认证** (设计题+代码，80分通过)：掌握多Block调度、优先级、CRC恢复
- 参考代码: examples/advanced/{ex05-ex10}
- 参考设计: docs/quiz/standard_design.md (开放设计题，30分钟)
- 通过后获得: eepromSim Standard Engineer Badge

**Expert认证** (综合实验，90分通过)：掌握故障注入、P0/P1恢复、系统测试
- 参考代码: examples/fault/{fault01-fault04}
- 参考实验: docs/quiz/expert_experiment.md (故障实验，60分钟)
- 通过后获得: eepromSim Expert Fault Handler Badge

### 3.3 RTM自动化追溯

```bash
# 生成完整的REQ→设计→代码→测试追溯矩阵
python tools/rtm_gen.py --examples examples/ --design design/ --code src/ --tests tests/

# 验证所有追溯完整性
python tools/rtm_verify.py --strict-mode
# ✓ 14/14 例子 100% 追溯完整
```

## 4. RTM钩子汇总

```
REQ-功能教学体系:
├─ REQ-NvM基础API → 02章§2.1 → {ex01,ex02} → src/nvm/nvm_api.c → test_api_*.c
├─ REQ-Block类型 → 03章§1 → {ex03,ex04,ex05,ex06} → src/nvm/block_*.c → test_*_type.c
├─ REQ-优先级调度 → 02§4+03§4 → {ex07,ex08} → src/nvm/job_queue.c → test_priority_*.c
├─ REQ-完整性恢复 → 04章§1~3 → {ex09,ex10} → src/nvm/data_integrity.c → test_*_recovery.c
└─ REQ-故障处理 → 01§4+04§3 → {fault01~04} → src/eeprom/fault_plugins/ → test_p{0,1}_*.c
```
